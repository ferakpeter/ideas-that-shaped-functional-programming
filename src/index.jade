doctype html
html
  head
    meta(charset='utf-8')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')
    title Ideas that shaped Functional Programming

    link(rel='stylesheet', type='text/css', href='build/build.css')

  body

    article

      section
        h1 Ideas that shaped Functional Programming
        h3
          a(href='https://twitter.com/ferakpeter') @ferakpeter
        img.avatar(src='images/profile.png')

      section
        img.avatar(src='images/codinghorror.png')
        br
        blockquote.
          Any application that <strong>can</strong> be written in JavaScript <strong>will</strong> eventually be written in JavaScript.
        br
        p
          a(href='https://twitter.com/codinghorror') Jeff Atwood

      section
        h2 Fast forward
        ul
          li Languages are going meta
          li Not restricted to the platform they will run on
          li Static Typing is very useful, especially for large applications
          li Developer Experience and tooling

      section
        h2 Let's branch into a different domain
        img.img--med(src='images/music.jpg')

      section
        h2 Where are the similarities?
        ul
          li Fast paced, constantly changing
          li Trends matter
          li "Open-source"
          li Highly dependend on "hardware"
          li Usually performed by groups of individuals with different skill-sets

      section
        h2 How is music taught?

      section
        img.img--full(src='images/music-teaching1.jpg')

      section
        img.img--full(src='images/radio.jpg')

      section
        h2 Music evolves all the time...

      section
        img.img--full(src='images/music-styles.jpg')

      section
        ul
          li Musical ideas spread through communities, communities influence each others
          li Changes are incremental and usually small
          li But sometimes there are game-changers (paradigm-shifts)

      section
        img.img--med(src='images/electric-guitar.jpg')

      section
        h2 The electric guitar changed everything

      section
        h2 Back to Programming languages

      section
        h2 1950's & 60's
        ul
          li FORTRAN
          li LISP
          li COBOL
          li BASIC

      section
        h2 1970's
        ul
          li Pascal
          li C
          li Smalltalk
          li ML

      section
        h2 1980's
        ul
          li C++
          li Common Lisp
          li Erlang
          li Perl

      section
        h2 1990's
        ul
          li Haskell
          li Python
          li Ruby
          li JS
          li PHP
          li OCaml

      section
        h2 2000's
        ul
          li C#
          li Scala
          li F#
          li Clojure
          li Go

      section
        h2 2010's
        ul
          li Rust
          li Dart
          li Kotlin
          li ReasonML

      section
        h2 OOP vs. FP

      section
        h2 OOP concepts are easier to misuse than FP
        ul
          li If objects are supposed to mutate each other with messages, why is this possible?
        pre
          code.language-javascript.
            var ret = '';
            ret = project.namespace + '.' + project.repository;
            ret += (project.subfolder === undefined
              || project.subfolder=='') ? '' : '.' + project.subfolder;
            ret += '.' + project.branch.replace(/\//g, '_');
            ret += (pipelineName === undefined) ? '' : '.' + pipelineName;
            return ret;

      section
        a(href='https://github.com/ferakpeter/nodejs-functional-example') example

      section
        h2 Backend

      section
        h2 Cloud was a new way to scale the backend
        img.img--med(src='images/horizontal-vs-vertical-scaling-vertical-and-horizontal-scaling-explained-diagram.png')

      section
        h2 Backend
        ul
          li Java and JVM better at squeezing all the juice out of a box
          li Functional paradigm better for stateless services

      section
        h2 Frontend

      section
        img.img--full(src='images/desktop-frontends.png')

      section
        img.img--full(src='images/web-frontend.jpg')

      section
        img.img--full(src='images/mobile-apps.jpg')

      section
        h2 Frontend
        ul
          li Devices (Desktop to Web to Mobile)
          li Space
          li UX
          li Product design more integrated with dev teams
          li Less clutter and smaller applications
          li That serve specific use-cases
          li State can be distributed between applications

      section
        img.img--full(src='images/programming-paradigms.jpg')
        Peter Van Roy

      section
        h2 Programming Paradigms
        ul
          li Both OOP and FP are designed to manage state in smaller chunks
          li Both are an answer to imperative procedural languages (GOTO:)

      section
        h2 Programming Paradigms
        h3 Object Oriented
        ul
          li Better at context
          li Less reusable for new contexts
          li Very flexible and open
          li Needs to be managed with patterns

        h3 Functional
        ul
          li Functions are generic building blocks
          li Context needs to be managed
          li More reusable smaller chunks
          li More rigid, built-in patterns

      section
        h2 As programmers we are like divers

      section
        h2 Readability is a big deal

      section
        h2 Context is also a big deal

      section
        h2 Reusable stable building blocks?

      section
        h1 Mathematics is different...

      section
        pre
          code.language-javascript.
            N + 1

      section
        h2 Basics of set theory
        pre
          code.language-haskell.
            r :: [a] → [a]

      section
        img.img--med(src='images/functions.png')

      section
        h2 First-order logic (expressed in Prolog)
        pre
          code.language-javascript.
            person(alan)
            person(grace)
            person(david)
            person(margaret)

            => person(turingmachine)
            > false.
            => person(alan)
            > true.

            father(alan, david)
            father(alan, margaret)
            mother(grace, david)
            mother(grace, margaret)

            sibling(X, Y) :-
              X \= Y,
              parent(P, X),
              parent(P, Y).

            => sibling(X, david)
            > X = david ;
              X = margaret ;

      section
        h2 Kaiser
        img.avatar.avatar--med(src='images/kaiser.png')
        ul
          li ... and Computer?

      section
        h2 David Hilbert
        img.avatar.avatar--med(src='images/hilbert.png')
        ul
          li Studied foundation of mathematics
          li Formal definition of an algorithm?
          li Entscheidungsproblem (the halting problem)

      section
        h2 Kurt Gödel
        img.avatar.avatar--med(src='images/goedel.png')
        ul
          li Logic is not complete
          li Incompleteness theorems (1931)
          li Prove that Hilbert's definition of Algorithm was not valid

      section
        h2 Logic is not a complete system
        ul
          li “This statement is not provable” written in arithmetic means that there is a valid expression that cannot be proven to be computable
          li In other words if you had a computer with infinate CPU and RAM, there will be calculation that will not compute
          li But it also means that a sub-system can be complete

      section
        h2 Alonzo Church
        img.avatar.avatar--med(src='images/church.png')
        ul
          li Lambda Calculus an attempt to formally define Algorithm
          li Gödel defines recursive functions
          li Church proves they are equivalent to Lambda Calculus

      section
        img.img--med(src='images/typed-lambda-calculus.png')

      section
        h2 Typed Lambda Calculus
        pre
          code.language-javascript.
            const TWO  = (f) => { return (v) => { return f(f(v)) }}

            // WAT.....
            const DECREMENT = (n) => {
              return (f) => { return (x) => {
                return n((g) => { return (h) =>
                { return h(g(f))}})((y) => { return x})((y) => { return y })
              }}
            }


            function toInt(x) {
              return x((v) => { return v + 1 })(0)
            }

            console.log(toInt(DECREMENT(TWO)))

            // next - multiply
        a(href='https://github.com/newportandy/lambda_example_code/blob/master/js/300-lambda.js') Andy Newport

      section
        h2 Alan Turing
        img.avatar.avatar--med(src='images/turing.png')
        ul
          li Turing settled the dispute
          li Church-Turing incompleteness thesis
          li 3 equivalent formal definitions of an algorithm: Church, Gödel, Turing

      section
        h2 Turing Machine & Turing completeness
        ul
          li Finite State Machines
          li With a tape
          li Turing Machine can operate on a program (another Turing Machine)

      section
        h2 Haskell Curry
        img.avatar.avatar--med(src='images/curry.png')
        ul
          li Curry–Howard correspondence
          li Curry–Howard isomorphism or equivalence
          li proofs-as-programs and propositions- or formulae-as-types interpretation

      section
        blockquote.
          Under the isomorphism, types correspond
          to propositions and members of those types, like pairs, functions and so
          on, to proofs.
        br
        p
          a(href='https://www.cs.kent.ac.uk/people/staff/sjt/TTFP/ttfp.pdf') Simon Thomson

      section
        h2 Writing a program within a system like Lambda-Calculus proves that it will compute.

      section
        h2 Hardware evolution
        img.img--full(src='images/computer-hardware-evolution.jpg')
        a(href='https://s-media-cache-ak0.pinimg.com/736x/a7/fd/24/a7fd245247f84d867fc9707bb6fbb430.jpg') source

      section
        h2 OOP vs. FP

      section
        img.avatar.avatar--med(src='images/anjana-vakil.jpg')
        br
        blockquote.
          Programming Across Paradigms
        br
        p
          a(href='https://youtu.be/Pg3UeB-5FdA') Anjana Vakil

      section
        h2 OOP like cells
        img.img--med(src='images/cells.jpg')

      section
        h2 FP like a factory
        img.img--med(src='images/factory.jpg')

      section
        h2 Programming Paradigms
        h3 Object Oriented
        ul
          li Better at context
          li Less reusable for new contexts
          li Very flexible and open
          li Needs to be managed with patterns

        h3 Functional
        ul
          li Functions are generic building blocks
          li Context needs to be managed
          li More reusable smaller chunks
          li More rigid, built-in patterns

      section
        h2 OOP like a car
        img.img--med(src='images/car.jpg')

      section
        h2 FP like a train
        img.img--med(src='images/train.jpg')

      section
        h2 What options are available to us?

      section
        h2 Combining more paradigms
        img.img--small(src='images/programming-paradigms.jpg')

      section
        h2 ...or creating new paradigms
        img.avatar(src='images/david-nolen.jpg')
        br
        blockquote.
          Idée Fixe
        br
        p
          a(href='https://www.youtube.com/watch?v=lzXHMy4ewtM') David Nolen

      section
        h2 Learning to work with new Paradigms enhances our toolbox!

      section
        h2 ...and helps reacting to big ideas
        img.img--med(src='images/electric-guitar.jpg')

      section
        h2 Follow hardware innovation
        img.img--full(src='images/evolution-of-cloud.jpg')

      section
        h1 What will be the next game changer?

      section
        h2 How will applications evolve?
        ul
          li Logging & Tracing (cryptic error messages)
          li "Lean" Application chunks instead of big frameworks (Tree-shaking)
          li Managing single points of failure (outsorced to the cloud)

      section
        h2 How will Infrastructure evolve?
        ul
          li In a sense Infrastructure is getting more abstract
          li Scaling managed by the cloud
          li Cold starts
          li Startup time
          li etc...

      section
        h2 What can ReasonML offer?

      section
        h2 ReasonML
        h3 Backend
        ul
          li Powerful compiler
          li Going closer to native
          li MirageOS
          li No more need for VM (JVM, Node, etc)
          li Functional by default, but not "closed"

        h3 Frontend
        ul
          li Great adition to Javascript
          li Adds to the ideas of React
          li Lots of room to grow

      section
        h2 btw... you don't need to be an electrical engineer to write a hit-song...

      section
        h2 but it doesn't hurt to get to know your instruments better!

      section
        h1 Thank you!
        h3
          a(href='https://twitter.com/ferakpeter') @ferakpeter
        img.avatar.avatar--small(src='images/profile.png')

      script(src='build/build.js')